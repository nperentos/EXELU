% 27/09/2025
% first script for basic data processing of EXELU data post dat and lfp creation
% KS has already ran at this stage by another script that resides on the recording PC
% the script is called convertDataEXELU.m

% TODO
% check that the spectra t-indices for the different conditions do not intersect
% save the spectra in each relevant folder so we dont have to recompute each time
% add the speed, theta and ripple for filtering epochs
% compute speed and resample at the spectrogram values
% add ripples to remove ripples
clear;
addpath(genpath('C:\Users\npere\MATLAB'));

dataPath = 'I:\';
fileBase = '2025-09-20_16-51-22';
session_path = fullfile(dataPath,fileBase);
load(fullfile(dataPath,fileBase,[fileBase,'.chanmap.mat']));
load(fullfile(dataPath,fileBase,'analog_events.mat'));
num_channels = length(chanMap);
[data,settings,tScale] = getLFP(fileBase, dataPath);

SR = str2num(settings.parameters.fieldPotentials.lfpSamplingRate.Text);

particulars = loadParticulars(fullfile(session_path,'session_particulars.txt'));

% keep the probe only the following parts

x = data(1:128,:); 
clear data; % just to keep some space

%% find bad channels - works for linear probe, not for multishank!
seg = x(1:100*SR,:);
seg = seg - median(seg,1);
C = size(seg,2);
rho = zeros(C-1,1);
for i = 1:C-1
    r = corr(seg(:,i), seg(:,i+1), 'type','Spearman'); % Spearman is robust
    rho(i) = r;
end
score = nan(C,1);
score(2:C-1) = (1-rho(1:C-2)) + (1-rho(2:C-1));  % high = suspicious
z = (score - median(score,'omitnan')) / (1.4826*mad(score,1));
idx_bad = find(z > 10);
% compute short segment psd to use for bad channel detection
movingwin = [1.5 1.5*0.2];
params.tapers = [2 3];    % Or [2 3] or [3 5] for less smoother spectra
params.Fs     = SR;       % Sampling rate (Hz)
params.fpass  = [0 200];   % Focus on theta band
params.pad    = 0;        % No additional frequency padding
% params.win    = [1 0.5];  % 1 s window, 0.5 s step (50% overlap)
[S_seg,t_seg,f_seg]=mtspecgramc(seg,movingwin,params);
S_seg = sq(mean(S_seg,1));
lineHz = 50;        % change to 60 if needed
bw = 1;             % +/- 1 Hz
lineBand  = f_seg > lineHz-bw & f_seg < lineHz+bw;
lfpBand   = f_seg > 1 & f_seg < 200;
linePower = sum(S_seg(lineBand,:),1);
lfpPower  = sum(S_seg(lfpBand,:),1);
lineRatio = linePower ./ lfpPower;
%combine the two metrics
score = sqrt(max(z,0).* max(zscore(lineRatio)',0));
bad_chans = find(score > 3);

%% SPECTRA
% theta spectrogram

    movingwin = [1.5 1.5*0.2];
    params.tapers = [3 5];    % Or [2 3] or [3 5] for less smoother spectra
    params.Fs     = SR;       % Sampling rate (Hz)
    params.fpass  = [0 60];   % Focus on theta band
    params.pad    = 0;        % No additional frequency padding
    % params.win    = [1 0.5];  % 1 s window, 0.5 s step (50% overlap)
    theta_ch = particulars.CA1_chan-7;
    tic;
    [S_theta,t_theta,f_theta]=mtspecgramc(x',movingwin,params); %(theta_ch,:) %28 seconds!
    toc
    % figure;
    % for i = 1:num_channels
    %     imagesc(t,f,S(:,:,i)');
    %     axis xy; title(['ch ',num2str(i)]);
    %     pause(0.2); cla;
    % end


% gamma spectrogram
    tic;
    movingwin = [0.2 0.2*0.2]; % 0.2 s x 20% overlap step
    params.tapers = [3 5];    % Or [2 3] for slightly smoother spectra
    params.Fs     = SR;     % Sampling rate (Hz)
    params.fpass  = [10 200];   % Focus on gamma band
    params.pad    = 1;        % No additional frequency padding
    % params.win    = [1 0.5];  % 1 s window, 0.5 s step (50% overlap)
    theta_ch = particulars.CA1_chan-7;
    
    % whitening is desirable
    whitenorder = 2;
    whitenwindow = 20 * SR; % 20sec window

    if size(x,1)<size(x,2); x = x'; end;
    if whitenwindow>size(x,1); whitenwindow = size(x,1); end; % In case signal is less than 20 sec

    for c=1:size(x,2);% cycle channels
        [A ,nv] = arburg(double(x(1:whitenwindow,c)),whitenorder);
        x(:,c) = filter(A,1,double(x(:,c)));
        options.NoiseVariance(c) = nv;
        options.WhitenModel(c,:) = A;
    end
    toc

    tic;
    [S,t,f]=mtspecgramc(x,movingwin,params); %(theta_ch,:) %28 seconds!
    S = single(S);
    toc; %  200 seconds
    % save the spectra to save 200s next time
    tic;save(fullfile(session_path,'gamma_spectra.mat'),'f','S','t','-v7.3'); toc
% running speed
runPulses = analogEvents{1,5}./30e3;
bins = 0:movingwin(1):max(runPulses)+0.1;
cnts = histcounts(runPulses,bins).*20*pi*9/600; % cm/s
speed_tmp = smooth(cnts,10); 
speed = interp1(bins(2:end),speed_tmp,t, 'nearest');
figure; plot(bins(1:end-1),speed_tmp); hold on;
plot(t,speed); 

% gather the relevant chunks for each condition. The events are in dat timescale 
% lets convert them to  

%static
    test = analogEvents{1,1}./30e3;
    test = reshape(test,2,[]);
    % t indices in the spectra matrix demarcating the start of the static exp.
    %idx = arrayfun(@(x) find(abs(t - x) == min(abs(t - x)), 1), test);
    idx = interp1(t, 1:numel(t), test, 'nearest');
    SegLen = median(diff(idx,1)); % should be about 10 s
    M = idx(1,:)' + (0:SegLen);
    M_static = vc(M');

    

    % the 10s after
    N_static = vc((idx(2,:)'+10 + (0:SegLen-20))');

% flashing
    % find diffs in pulse times that exceed 5s
    test = analogEvents{1,2}./30e3;
    
    idx_end = [find(diff(test) > 5) ];
    idx_strt= [1 idx_end(1:end-1)+1];

    idx = interp1(t, 1:numel(t), test(idx_strt), 'nearest');
    M = idx(1,:)' + (0:SegLen);
    M_flashing = vc(M');
    
    % the 10s after
    idx = interp1(t, 1:numel(t), test(idx_end), 'nearest');
    N_flashing = vc((idx'+10 + (0:SegLen-20))');


% reversing
    % find diffs in pulse times that exceed 5s
    test = analogEvents{1,4}./30e3;
    
    idx_end = [find(diff(test) > 5) ];
    idx_strt= [1 idx_end(1:end-1)+1];

    idx = interp1(t, 1:numel(t), test(idx_strt), 'nearest');
    M = idx(1,:)' + (0:SegLen);
    M_reversing = vc(M');

    % the 10s after
    idx = interp1(t, 1:numel(t), test(idx_end), 'nearest');
    N_reversing = vc((idx'+10 + (0:SegLen-20))');

% visual compare same channel different conditions
    
    figure; 
    for ch = 1:2:128
        subplot(321); imagesc(t(M_static),f   ,S(M_static,:,ch)'); axis xy; title('static grating ');colorbar;
        subplot(323); imagesc(t(M_flashing),f ,S(M_flashing,:,ch)'); axis xy; title('full field flashing at 40 Hz');colorbar;
        subplot(325); imagesc(t(M_reversing),f ,S(M_reversing,:,ch)'); axis xy; title('reversing gratings');colorbar;
        subplot(322); imagesc(t(N_static),f ,S(N_static,:,ch)'); axis xy; title('no stim');colorbar;
        subplot(324); imagesc(t(N_flashing),f ,S(N_flashing,:,ch)'); axis xy; title('no stim');colorbar;
        subplot(326); imagesc(t(N_reversing),f ,S(N_reversing,:,ch)'); axis xy; title('no stim');colorbar;
        mod_all_plots('clim([0 150])');
        pause;%(0.2);clf
    end



% lets average and get spectra rather than spectroghrams for each state.
% figure; 
avgs = [];
for ch = 1:size(S,3) % n of chans

% Static
    S_tmp = S(M_static,:,ch)';
    ttt = sum(S_tmp,1);
    thr = prctile(ttt,95);
    keep = find(ttt < thr);
    S_av = mean(S_tmp(:,keep),2);
    avgs(:,1,ch) = S_av;
    if intersect(ch,bad_chans);  disp(['cj',num2str(ch),' match...']); avgs(:,1,ch) = nan; end
    % plot(f,S_av,'LineWidth',2); hold on;
    
% Flashing
    S_tmp = S(M_flashing,:,ch)';
    ttt = sum(S_tmp,1);
    thr = prctile(ttt,95);
    keep = find(ttt < thr);
    S_av = mean(S_tmp(:,keep),2);
    avgs(:,2,ch) = S_av;
    if intersect(ch,bad_chans);  disp(['cj',num2str(ch),' match...']); avgs(:,2,ch) = nan; end
    % plot(f,S_av,'LineWidth',2); 
    
% Reversing
    S_tmp = S(M_reversing,:,ch)';
    ttt = sum(S_tmp,1);
    thr = prctile(ttt,95);
    keep = find(ttt < thr);
    S_av = mean(S_tmp(:,keep),2);    
    avgs(:,3,ch) = S_av;
    if intersect(ch,bad_chans);  disp(['cj',num2str(ch),' match...']); avgs(:,3,ch) = nan; end
    % plot(f,S_av,'LineWidth',2); 

end
figure; 
ttl = {'static','flashing','reversing'};
for i = 1:3
    plt_data = zscore(sq(avgs(:,i,:)),0,1)';
    subplot(3,1,i); h=imagesc(f,[1:size(S,3)],plt_data);title(ttl{i});xlabel('f (Hz)');ylabel('depth');
    set(gca,'Color',[1 1 1]);  % gray background
    set(h,'AlphaData',~isnan(plt_data));  
    colorbar;
end
mod_all_plots('clim([-3 3])');
set(gcf,'color','white');



    %out = specmt_low_mem(data([theta_ch:theta_ch+2],:)',{'defaults','gamma','blocksize',2^10}); %data(1:2:end,:) 
out = specmt_low_mem(data([1:3],:)',{'defaults','gamma','blocksize',2^10}); %data(1:2:end,:) 
%%




test = analogEvents{1};
test =reshape(test,2,floor(length(test)/2));
durations = test(2,:)-test(1,:);











% % we need to run some corrections on the event detection since the script used had 
% % an incorrect event indexing method
% fbs = {'2025-09-18_09-59-40','2025-09-18_20-10-12','2025-09-20_10-49-09', ...
% '2025-09-20_13-33-23','2025-09-20_16-51-22'};
% dataPath = 'I:\';
% 
% for j = 1:length(fbs)
%     fileBase = fbs{j};
%     load(fullfile(dataPath,fileBase,'analog_events.mat'));
%     load(fullfile(dataPath,fileBase,[fileBase,'.chanmap.mat']));
%     num_channels = length(chanMap);
%     fle = fullfile(dataPath,fileBase,[fileBase,'.dat']);
%     fid = fopen(fle);
%     fseek(fid,0,'eof');
%     len = ftell(fid);
%     len = len/(num_channels*2);
%     m = memmapfile(fle,'Format',{'int16',[num_channels len],'m'},'writable',false);
%     d = m.Data.m;
%     ev_chans = [135:139];
%     ADCs = d(ev_chans,:);
% 
%     for i = 1:size(ADCs,1)
%         test = double(ADCs(i,:));
%         tmp1 = find(test(1:end-1)>max(test)*.75); % if this occasionaly doesnt work we have to switch to prctile
%         tmp2 = find(test(2:end)>max(test)*.75);
%         [both, fall, rise] = setxor(tmp1,tmp2);
%         analogEvents{i} = tmp1(rise); % add names of event channels as per arduino connections and correspondece to the py code conditions
%     end
%     analog_ch_names{5} = 'run_encoder';
%     % overwrite the analog_events.mat
%     save(fullfile(dataPath,fileBase,'analog_events.mat'),'analogEvents','analog_ch_names','user_msgs','ts_user_msgs');
% end
% 
% 
% 
% 
% 
% % we should make a session variable that holds
% 
% session.events =
% session.num_channels = 
% session.SR = 
% session.ADCs = 
% session.speed = 
% session.CA1
% session.V4